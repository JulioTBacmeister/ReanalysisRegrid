import numpy as np
import xarray as xr
from datetime import datetime
import sys
import copy

#from itertools import product

#import esmlab

#import matplotlib.pyplot as plt


#def latlon_to_scrip(nx, ny, lon0=-180., grid_imask=None, file_out=None):
def latlon_to_scrip( grid_imask=None, file_out=None, **kwargs ):
    """Generate a SCRIP grid file for a regular lat x lon grid.
    
    Parameters
    ----------
    grid_imask : array-like, optional [default=None]       
       If the value is set to 0 for a grid point, then that point is
       considered masked out and won't be used in the weights 
       generated by the application. 
    file_out : string, optional [default=None]
       File to which to write the grid.

    Some possible kwargs
    --------------------
    nx : int
       Number of points in x (longitude).
    ny : int
       Number of points in y (latitude).

    Returns
    -------
    ds : xarray.Dataset
       The grid file dataset.       
    """
    
    if ('SkipAreaCheck' in kwargs):
        SkipAreaCheck_ = kwargs[ 'SkipAreaCheck' ]
    else:
        SkipAreaCheck_ = False
    
    if ('myGrid' in kwargs):
        if ('S_edge' in kwargs):
            s_edge = kwargs['S_edge']
        else:
            s_edge = -90.
        if ('N_edge' in kwargs):
            n_edge = kwargs['N_edge']
        else:
            n_edge = 90.
        if ('W_edge' in kwargs):
            w_edge = kwargs['W_edge']
        else:
            w_edge = 0.
        if ('E_edge' in kwargs):
            e_edge = kwargs['E_edge']
        else:
            e_edge = 360.

        lon_span = e_edge - w_edge
        lat_span = n_edge - s_edge

        if ('nx' in kwargs) and ('ny' in kwargs):
            # compute coordinates of regular grid
            nx = kwargs['nx']
            ny = kwargs['ny']
            dx = lon_span / nx
            dy = lat_span / ny
            lat = np.arange(s_edge + dy / 2., n_edge , dy)
            lon = np.arange(w_edge + dx / 2., e_edge , dx)

        if ('dx' in kwargs) and ('dy' in kwargs):
            # compute coordinates of regular grid
            dx = kwargs['dx']
            dy = kwargs['dy']
            lat = np.arange(s_edge + dy / 2., n_edge , dy)
            lon = np.arange(w_edge + dx / 2., e_edge , dx)
            nx = len( lon )
            ny = len( lat) 
            print( f" myGrid w_edge={w_edge} ,e_edge={e_edge}, s_edge={s_edge} ,n_edge={n_edge} ")
            print( f" myGrid nx={nx} ,ny={ny} ")
 
        # make 2D
        y_center = np.broadcast_to(lat[:, None], (ny, nx))
        x_center = np.broadcast_to(lon[None, :], (ny, nx))

        # compute corner points: must be counterclockwise
        y_corner = np.stack((y_center - dy / 2.,  # SW
                             y_center - dy / 2.,  # SE
                             y_center + dy / 2.,  # NE
                             y_center + dy / 2.), # NW
                            axis=2)

        x_corner = np.stack((x_center - dx / 2.,  # SW
                             x_center + dx / 2.,  # SE
                             x_center + dx / 2.,  # NE
                             x_center - dx / 2.), # NW
                            axis=2)

        if (lon_span < 360.) or (lat_span<180.):
            # Don't worry about matching 4*pi for non-global grid
            SkipAreaCheck_ = True
        
    elif (('longitudes' in kwargs) and ('latitudes' in kwargs)):
        lat = kwargs['latitudes']
        lon = kwargs['longitudes']

        nx  = np.size( lon )
        ny  = np.size( lat )

        lat_e = np.zeros( ny+1 )
        lat_c = np.zeros( ny )
        dlon = np.zeros( nx )
        dlat = np.zeros( ny )
        for j in np.arange(start=0,stop=ny-1):
            lat_e[j+1]=(lat[j]+lat[j+1])/2.
            #print( j,j+1, lat[j],lat[j+1],lat_e[j+1] )
        
        if (lat[0]< -85.):
            lat_e[0]=-90.
            lat_e[ny]=90.
        if (lat[0]> -85.):
            lat_e[0]=90.
            lat_e[ny]=-90.
   
        dlon[:] = np.abs( lon[1]-lon[0] )
        
        for j in np.arange(start=0,stop=ny):
            dlat[j] =np.abs(lat_e[j]-lat_e[j+1])
            lat_c[j]=(lat_e[j]+lat_e[j+1])/2.
            #print( j,j+1, lat[j],lat[j+1],lat_e[j+1] )
            if ( (j<5) or (j>ny-5) ):
                print( j, lat[j],dlat[j],lat_e[j],lat_e[j+1] )

        ###################################################################
        # ChatGPT struggled a bit with why I was getting negative
        # areas for NOAA SSTs, but in the end we figured it out. This needs 
        # to be here to ensure JNorth and JSouth are crrect for all grids.
        # Check if latitudes are increasing or decreasing
        ###################################################################
        if lat[0] > lat[-1]:
            JNorth = np.arange(start=0, stop=ny)
            JSouth = np.arange(start=1, stop=ny+1)
        else:
            JNorth = np.arange(start=1, stop=ny+1)
            JSouth = np.arange(start=0, stop=ny)

        # make 2D
        y_edge   = np.broadcast_to(lat_e[:, None], (ny+1, nx))
        y_center = np.broadcast_to(lat[:, None], (ny, nx))
        x_center = np.broadcast_to(lon[None, :], (ny, nx))
        dy       = np.broadcast_to(dlat[:, None], (ny, nx))
        dx       = np.broadcast_to(dlon[None, :], (ny, nx))

        # compute corner points: must be counterclockwise
        y_corner = np.stack((y_edge[JSouth,:],  # SW
                             y_edge[JSouth,:],  # SE
                             y_edge[JNorth,:],  # NE
                             y_edge[JNorth,:] ), # NW
                            axis=2)
        x_corner = np.stack((x_center - dx / 2.,  # SW
                             x_center + dx / 2.,  # SE
                             x_center + dx / 2.,  # NE
                             x_center - dx / 2.), # NW
                            axis=2)
    
    else:
        try:
            lon in locals()
        except:
            print("lat-lon not provided and can't be calculated ")
            return -99999.

            
    print( "Shape Centers ", np.shape( y_center ))
    print( "Shape Corners ", np.shape( y_corner ))
    
    # compute area
    y0 = y_corner[:, :, 0] * np.pi / 180.   # south
    y1 = y_corner[:, :, 3] * np.pi / 180.   # north
    x0 = x_corner[:, :, 0] * np.pi / 180.   # west
    x1 = x_corner[:, :, 1] * np.pi / 180.   # east
    yC = y_center[:,:] * np.pi / 180.       # cell center
    grid_area = ( np.sin(y1) - np.sin(y0) ) * (x1 - x0)
    
    # sum of area should be equal to area of sphere
    if (SkipAreaCheck_ == True):
        print( " no test for area " )
    else:
        np.testing.assert_allclose(grid_area.sum(), 4.*np.pi)
    
    print( grid_area.sum(), 4.*np.pi, grid_area.sum() - 4.*np.pi,  )
    
    # construct mask
    if grid_imask is None:
        grid_imask = np.ones((ny, nx), dtype=np.int32)
    
    # generate output dataset
    dso = xr.Dataset()    
    dso['grid_dims'] = xr.DataArray(np.array([nx, ny], dtype=np.int32), 
                                    dims=('grid_rank',)) 
    dso.grid_dims.encoding = {'dtype': np.int32}

    dso['grid_center_lat'] = xr.DataArray(y_center.reshape((-1,)), 
                                          dims=('grid_size'),
                                          attrs={'units': 'degrees'})

    dso['grid_center_lon'] = xr.DataArray(x_center.reshape((-1,)), 
                                          dims=('grid_size'),
                                          attrs={'units': 'degrees'})
    
    dso['grid_corner_lat'] = xr.DataArray(y_corner.reshape((-1, 4)), 
                                          dims=('grid_size', 'grid_corners'), 
                                          attrs={'units': 'degrees'})
    dso['grid_corner_lon'] = xr.DataArray(x_corner.reshape((-1, 4)), 
                                      dims=('grid_size', 'grid_corners'), 
                                      attrs={'units': 'degrees'})    

    dso['grid_imask'] = xr.DataArray(grid_imask.reshape((-1,)), 
                                     dims=('grid_size'),
                                     attrs={'units': 'unitless'})
    dso.grid_imask.encoding = {'dtype': np.int32}
    
    dso['grid_area'] = xr.DataArray(grid_area.reshape((-1,)), 
                                     dims=('grid_size'),
                                     attrs={'units': 'radians^2',
                                            'long_name': 'area weights'})
    
    # force no '_FillValue' if not specified
    for v in dso.variables:
        if '_FillValue' not in dso[v].encoding:
            dso[v].encoding['_FillValue'] = None

    dso.attrs = {'title': f'{dy} x {dx} (lat x lon) grid',
                 'created_by': 'latlon_to_scrip',
                 'date_created': f'{datetime.now()}',
                 'conventions': 'SCRIP',
                }
            
    # write output file
    if file_out is not None:
        print(f'writing {file_out}')
        dso.to_netcdf(file_out)
        
    return dso
    
